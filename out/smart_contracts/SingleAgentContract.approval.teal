#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "ownerAddress" "taskCount" "fixedPricing" 0x00 0x0033
    // smart_contracts/Agent.algo.ts:32
    // export class SingleAgentContract extends Contract {
    txn NumAppArgs
    bz main_after_if_else@11
    pushbytess 0xc04b75f4 0x6b680318 0xc5463eea 0xee33912f 0xf3baa270 // method "createApplication(string,string,uint64)void", method "pay(pay)void", method "updateTask(uint64,bool,bool,bool,bool,string,address)void", method "withdraw(account,uint64)void", method "transferOwnership(account)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_pay_route@4 main_updateTask_route@5 main_withdraw_route@6 main_transferOwnership_route@7

main_after_if_else@11:
    // smart_contracts/Agent.algo.ts:32
    // export class SingleAgentContract extends Contract {
    intc_0 // 0
    return

main_transferOwnership_route@7:
    // smart_contracts/Agent.algo.ts:137
    // transferOwnership(newOwner: Account): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/Agent.algo.ts:32
    // export class SingleAgentContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/Agent.algo.ts:137
    // transferOwnership(newOwner: Account): void {
    callsub transferOwnership
    intc_1 // 1
    return

main_withdraw_route@6:
    // smart_contracts/Agent.algo.ts:114
    // withdraw(to: Account, amount: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/Agent.algo.ts:32
    // export class SingleAgentContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    btoi
    // smart_contracts/Agent.algo.ts:114
    // withdraw(to: Account, amount: uint64): void {
    callsub withdraw
    intc_1 // 1
    return

main_updateTask_route@5:
    // smart_contracts/Agent.algo.ts:91-99
    // updateTask(
    //   idx: uint64,
    //   updateSuccess: arc4.Bool,
    //   updateDetails: arc4.Bool,
    //   updateExecutor: arc4.Bool,
    //   success: arc4.Bool,
    //   details: arc4.Str,
    //   executor: Address
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/Agent.algo.ts:32
    // export class SingleAgentContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    // smart_contracts/Agent.algo.ts:91-99
    // updateTask(
    //   idx: uint64,
    //   updateSuccess: arc4.Bool,
    //   updateDetails: arc4.Bool,
    //   updateExecutor: arc4.Bool,
    //   success: arc4.Bool,
    //   details: arc4.Str,
    //   executor: Address
    // ): void {
    callsub updateTask
    intc_1 // 1
    return

main_pay_route@4:
    // smart_contracts/Agent.algo.ts:63
    // pay(payTxn: gtxn.PaymentTxn): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/Agent.algo.ts:32
    // export class SingleAgentContract extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/Agent.algo.ts:63
    // pay(payTxn: gtxn.PaymentTxn): void {
    callsub pay
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/Agent.algo.ts:49
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/Agent.algo.ts:32
    // export class SingleAgentContract extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    // smart_contracts/Agent.algo.ts:49
    // @abimethod()
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/Agent.algo.ts::SingleAgentContract.createApplication(agentName: bytes, agentDetails: bytes, pricing: uint64) -> void:
createApplication:
    // smart_contracts/Agent.algo.ts:49-50
    // @abimethod()
    // createApplication(agentName: string, agentDetails: string, pricing: uint64): void {
    proto 3 0
    // smart_contracts/Agent.algo.ts:39
    // ownerAddress = GlobalState<Account>();
    bytec_0 // "ownerAddress"
    // smart_contracts/Agent.algo.ts:52
    // this.ownerAddress.value = Txn.sender ;
    txn Sender
    app_global_put
    // smart_contracts/Agent.algo.ts:34
    // name = GlobalState<string>();
    pushbytes "name"
    // smart_contracts/Agent.algo.ts:53
    // this.name.value = agentName;
    frame_dig -3
    app_global_put
    // smart_contracts/Agent.algo.ts:35
    // details = GlobalState<string>();
    pushbytes "details"
    // smart_contracts/Agent.algo.ts:54
    // this.details.value = agentDetails;
    frame_dig -2
    app_global_put
    // smart_contracts/Agent.algo.ts:36
    // fixedPricing = GlobalState<uint64>();
    bytec_2 // "fixedPricing"
    // smart_contracts/Agent.algo.ts:55
    // this.fixedPricing.value = pricing;
    frame_dig -1
    app_global_put
    // smart_contracts/Agent.algo.ts:37
    // createdAt = GlobalState<uint64>();
    pushbytes "createdAt"
    // smart_contracts/Agent.algo.ts:56
    // this.createdAt.value = Global.latestTimestamp;
    global LatestTimestamp
    app_global_put
    // smart_contracts/Agent.algo.ts:41
    // taskCount = GlobalState<uint64>();
    bytec_1 // "taskCount"
    // smart_contracts/Agent.algo.ts:57
    // this.taskCount.value = 0 as uint64;
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/Agent.algo.ts::SingleAgentContract.pay(payTxn: uint64) -> void:
pay:
    // smart_contracts/Agent.algo.ts:63
    // pay(payTxn: gtxn.PaymentTxn): void {
    proto 1 0
    // smart_contracts/Agent.algo.ts:36
    // fixedPricing = GlobalState<uint64>();
    intc_0 // 0
    bytec_2 // "fixedPricing"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/Agent.algo.ts:65
    // const expectedAmount: uint64 = Uint64(this.fixedPricing.value * 1_000_000);
    pushint 1000000 // 1000000
    *
    // smart_contracts/Agent.algo.ts:67
    // assert(payTxn.receiver === Global.currentApplicationAddress, 'payment must be to app');
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // payment must be to app
    // smart_contracts/Agent.algo.ts:68
    // assert(payTxn.amount === expectedAmount, 'Incorrect payment amount');
    frame_dig -1
    gtxns Amount
    ==
    assert // Incorrect payment amount
    // smart_contracts/Agent.algo.ts:41
    // taskCount = GlobalState<uint64>();
    intc_0 // 0
    bytec_1 // "taskCount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/Agent.algo.ts:75
    // id: new arc4.UintN64(idx),
    dup
    itob
    // smart_contracts/Agent.algo.ts:77
    // timestamp: new arc4.UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/Agent.algo.ts:79
    // executor: new Address(payTxn.sender)
    frame_dig -1
    gtxns Sender
    // smart_contracts/Agent.algo.ts:74-80
    // const task = new Task({
    //   id: new arc4.UintN64(idx),
    //   success: new arc4.Bool(false),
    //   timestamp: new arc4.UintN64(Global.latestTimestamp),
    //   details: new arc4.Str("Payment Done!!, Task Created"),
    //   executor: new Address(payTxn.sender)
    // });
    dig 2
    // smart_contracts/Agent.algo.ts:76
    // success: new arc4.Bool(false),
    bytec_3 // 0x00
    // smart_contracts/Agent.algo.ts:74-80
    // const task = new Task({
    //   id: new arc4.UintN64(idx),
    //   success: new arc4.Bool(false),
    //   timestamp: new arc4.UintN64(Global.latestTimestamp),
    //   details: new arc4.Str("Payment Done!!, Task Created"),
    //   executor: new Address(payTxn.sender)
    // });
    concat
    uncover 2
    concat
    bytec 4 // 0x0033
    concat
    swap
    concat
    // smart_contracts/Agent.algo.ts:78
    // details: new arc4.Str("Payment Done!!, Task Created"),
    pushbytes 0x001c5061796d656e7420446f6e6521212c205461736b2043726561746564
    // smart_contracts/Agent.algo.ts:74-80
    // const task = new Task({
    //   id: new arc4.UintN64(idx),
    //   success: new arc4.Bool(false),
    //   timestamp: new arc4.UintN64(Global.latestTimestamp),
    //   details: new arc4.Str("Payment Done!!, Task Created"),
    //   executor: new Address(payTxn.sender)
    // });
    concat
    // smart_contracts/Agent.algo.ts:82
    // this.taskBox(idx).value = task.copy();
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/Agent.algo.ts:85
    // this.taskCount.value = (idx + (1 as uint64)) as uint64;
    intc_1 // 1
    +
    // smart_contracts/Agent.algo.ts:41
    // taskCount = GlobalState<uint64>();
    bytec_1 // "taskCount"
    // smart_contracts/Agent.algo.ts:85
    // this.taskCount.value = (idx + (1 as uint64)) as uint64;
    swap
    app_global_put
    retsub


// smart_contracts/Agent.algo.ts::SingleAgentContract.updateTask(idx: uint64, updateSuccess: bytes, updateDetails: bytes, updateExecutor: bytes, success: bytes, details: bytes, executor: bytes) -> void:
updateTask:
    // smart_contracts/Agent.algo.ts:91-99
    // updateTask(
    //   idx: uint64,
    //   updateSuccess: arc4.Bool,
    //   updateDetails: arc4.Bool,
    //   updateExecutor: arc4.Bool,
    //   success: arc4.Bool,
    //   details: arc4.Str,
    //   executor: Address
    // ): void {
    proto 7 0
    intc_0 // 0
    dup
    // smart_contracts/Agent.algo.ts:100
    // const currentTask = this.taskBox(idx).value.copy();
    frame_dig -7
    itob
    dup
    box_get
    assert // Box must have value
    // smart_contracts/Agent.algo.ts:105
    // timestamp: new arc4.UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/Agent.algo.ts:106
    // success: updateSuccess.native ? success : currentTask.success,
    frame_dig -6
    intc_0 // 0
    getbit
    bz updateTask_ternary_false@2
    frame_dig -3
    frame_bury 0

updateTask_ternary_merge@3:
    // smart_contracts/Agent.algo.ts:107
    // details: updateDetails.native ? details : currentTask.details,
    frame_dig -5
    intc_0 // 0
    getbit
    bz updateTask_ternary_false@5
    frame_dig -2
    frame_bury 1

updateTask_ternary_merge@6:
    // smart_contracts/Agent.algo.ts:108
    // executor: updateExecutor.native ? executor : currentTask.executor,
    frame_dig -4
    intc_0 // 0
    getbit
    bz updateTask_ternary_false@8
    frame_dig -1

updateTask_ternary_merge@9:
    // smart_contracts/Agent.algo.ts:103-109
    //     const updatedTask = new Task({
    //   id: new arc4.UintN64(idx),
    //   timestamp: new arc4.UintN64(Global.latestTimestamp),
    //   success: updateSuccess.native ? success : currentTask.success,
    //   details: updateDetails.native ? details : currentTask.details,
    //   executor: updateExecutor.native ? executor : currentTask.executor,
    // });
    frame_dig 2
    dup
    frame_dig 0
    concat
    frame_dig 4
    concat
    bytec 4 // 0x0033
    concat
    uncover 2
    concat
    frame_dig 1
    concat
    // smart_contracts/Agent.algo.ts:111
    // this.taskBox(idx).value = updatedTask.copy();
    dig 1
    box_del
    pop
    box_put
    retsub

updateTask_ternary_false@8:
    // smart_contracts/Agent.algo.ts:108
    // executor: updateExecutor.native ? executor : currentTask.executor,
    frame_dig 3
    extract 19 32 // on error: Index access is out of bounds
    b updateTask_ternary_merge@9

updateTask_ternary_false@5:
    // smart_contracts/Agent.algo.ts:107
    // details: updateDetails.native ? details : currentTask.details,
    frame_dig 3
    dup
    pushint 17 // 17
    extract_uint16
    dig 1
    len
    substring3
    frame_bury 1
    b updateTask_ternary_merge@6

updateTask_ternary_false@2:
    // smart_contracts/Agent.algo.ts:106
    // success: updateSuccess.native ? success : currentTask.success,
    frame_dig 3
    pushint 64 // 64
    getbit
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    frame_bury 0
    b updateTask_ternary_merge@3


// smart_contracts/Agent.algo.ts::SingleAgentContract.withdraw(to: bytes, amount: uint64) -> void:
withdraw:
    // smart_contracts/Agent.algo.ts:114
    // withdraw(to: Account, amount: uint64): void {
    proto 2 0
    // smart_contracts/Agent.algo.ts:115
    // assert(Txn.sender === this.ownerAddress.value, 'only owner');
    txn Sender
    // smart_contracts/Agent.algo.ts:39
    // ownerAddress = GlobalState<Account>();
    intc_0 // 0
    bytec_0 // "ownerAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/Agent.algo.ts:115
    // assert(Txn.sender === this.ownerAddress.value, 'only owner');
    ==
    assert // only owner
    // smart_contracts/Agent.algo.ts:117-123
    // itxn
    //   .payment({
    //     amount: amount,
    //     receiver: to,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    frame_dig -2
    itxn_field Receiver
    frame_dig -1
    itxn_field Amount
    // smart_contracts/Agent.algo.ts:117-122
    // itxn
    //   .payment({
    //     amount: amount,
    //     receiver: to,
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/Agent.algo.ts:121
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/Agent.algo.ts:117-123
    // itxn
    //   .payment({
    //     amount: amount,
    //     receiver: to,
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/Agent.algo.ts:126-131
    // const callTxn = itxn
    //       .applicationCall({
    //         appId:appID,
    //         appArgs: [arc4.methodSelector('emit_log(string,application,string)'), new arc4.Str('withdraw'), Application(Global.currentApplicationId.id), new arc4.Str("sucess") ],
    //       })
    //       .submit()
    itxn_begin
    // smart_contracts/Agent.algo.ts:129
    // appArgs: [arc4.methodSelector('emit_log(string,application,string)'), new arc4.Str('withdraw'), Application(Global.currentApplicationId.id), new arc4.Str("sucess") ],
    global CurrentApplicationID
    itob
    pushbytes 0xc6c45014 // method "emit_log(string,application,string)"
    itxn_field ApplicationArgs
    pushbytes 0x00087769746864726177
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    pushbytes 0x0006737563657373
    itxn_field ApplicationArgs
    // smart_contracts/Agent.algo.ts:124
    // const appID =  Application(747862402);
    pushint 747862402 // 747862402
    itxn_field ApplicationID
    // smart_contracts/Agent.algo.ts:126-130
    // const callTxn = itxn
    //       .applicationCall({
    //         appId:appID,
    //         appArgs: [arc4.methodSelector('emit_log(string,application,string)'), new arc4.Str('withdraw'), Application(Global.currentApplicationId.id), new arc4.Str("sucess") ],
    //       })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/Agent.algo.ts:126-131
    // const callTxn = itxn
    //       .applicationCall({
    //         appId:appID,
    //         appArgs: [arc4.methodSelector('emit_log(string,application,string)'), new arc4.Str('withdraw'), Application(Global.currentApplicationId.id), new arc4.Str("sucess") ],
    //       })
    //       .submit()
    itxn_submit
    retsub


// smart_contracts/Agent.algo.ts::SingleAgentContract.transferOwnership(newOwner: bytes) -> void:
transferOwnership:
    // smart_contracts/Agent.algo.ts:137
    // transferOwnership(newOwner: Account): void {
    proto 1 0
    // smart_contracts/Agent.algo.ts:138
    // assert(Txn.sender === this.ownerAddress.value, 'only owner');
    txn Sender
    // smart_contracts/Agent.algo.ts:39
    // ownerAddress = GlobalState<Account>();
    intc_0 // 0
    bytec_0 // "ownerAddress"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/Agent.algo.ts:138
    // assert(Txn.sender === this.ownerAddress.value, 'only owner');
    ==
    assert // only owner
    // smart_contracts/Agent.algo.ts:39
    // ownerAddress = GlobalState<Account>();
    bytec_0 // "ownerAddress"
    // smart_contracts/Agent.algo.ts:139
    // this.ownerAddress.value = newOwner;
    frame_dig -1
    app_global_put
    retsub
